{"pages":[],"posts":[{"title":"Git常用命令","text":"记录一下 备忘学习地址：http://www.liaoxuefeng.com/http://stormzhang.com/github/2016/07/09/learn-from-github-from-zero6/ git 安装 配置 安装 配置1234567891011$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; //非必要配置 (可查看上面的学习地址)git config --global color.ui true//让Git显示颜色，会让命令输出看起来更醒目：忽略特殊文件配置别名 ... 基本命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546git init //创建git版本库git add &lt;file&gt; //添加到暂存区git add * 添加所有（不包括.gitignore 配置的忽略内容）git rm &lt;file&gt; //删除文件git commit -m &quot;描述&quot; //提交到版本库git status //状态查看git diff //查看修改内容git log //提交历史 git log --pretty=oneline git log --graph //查看分支合并图git reflog //命令历史git reset --hard HEAD^ //版本回退 上一版本 前多少版本 head~数字git reset --hard 3628164 //根据commitid进行版本回退git checkout -- &lt;file&gt; //丢弃工作区的修改（实是用版本库里的版本替换工作区的版本）git reset HEAD &lt;file&gt; //丢弃暂存区的修改git tag &lt;name&gt;//用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;//可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;//可以用PGP签名标签；git tag//可以查看所有标签。git push origin &lt;tagname&gt;//可以推送一个本地标签；git push origin --tags//可以推送全部未推送过的本地标签；git tag -d &lt;tagname&gt;//可以删除一个本地标签；git push origin :refs/tags/&lt;tagname&gt;//可以删除一个远程标签。git show &lt;tagname&gt;//查看标签信息git checkout tag/commitid //版本回退 git 结合远程库 的一些命令12345678910111213141516ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //生成ssh keyssh -T git@github.com //测试是否能够连接git remote add origin git@github.com:michaelliao/learngit.git //建立本地和远程库关联 远程库的名字就是origin，这是Git默认的叫法git push origin &lt;分支名称&gt; //推送到远程 第一次要 加 -u 建立分支关联git clone git@github.com:michaelliao/gitskills.git //克隆 默认是mastergit clone -b &lt;指定分支名称&gt; git@github.com:michaelliao/gitskills.git //克隆指定分支git pull //从远程抓取最新的提交git remote -v //查看远程库信息git remote remove origin 解除和远程库关联 .gitignore配置.gitginore 也要同步上传的远程库 123/.idea/*.iml/target/ 分支管理 如果你是一个人开发，可能只需要 master、develop 两个分支就 ok 了，平时开发在 develop 分支进行，开发完成之后，发布之前合并到 master 分支 1234567891011121314151617181920212223git branch //查看分支git branch &lt;name&gt; //创建分支git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建+切换分支git merge &lt;name&gt; //合并某分支到当前分支//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并git branch -d &lt;name&gt; //删除分支git branch -D &lt;name&gt; //丢弃一个没有被合并过的分支git stashgit stash pop //回到工作现场git stash listgit checkout -b branch-name origin/branch-name//在本地创建和远程分支对应的分支git branch --set-upstream branch-name origin/branch-name //建立本地分支和远程分支的关联 checkout切换分支123git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建+切换分支git checkout -b branch-name origin/branch-name //在本地创建和远程分支对应的分支 切换tag，切换到某次commit 1git checkout tag/commitid //版本回退 撤销checkout -- link1 补充一. reset的hard，soft，mixed参数区别 git reset :和git add命令作用相反，撤销add操作，把index区内容撤销到working directory git reset的–hard –mixed –soft参数区别：hard：把working directory和index区的内容都重置为指定的commit 版本soft：保留现在working directory和index区的内容，HEAD指向制定的commit 版本mixed：保留working区的内容，将index区和HEAD内容都修恢复到指定的commit版本 二. reset和revert区别 reset是回朔到指定的commit版本（指定commit版本之后的操作都消失了）。revert是删除指定的commit操作的内容（指定的版本内容消失，之前和之后commit版本内的操作都保留），但是这个操作也会做了一个commit提交版本。 三： 如果本地的版本回退使用reset的话, push 到 远程库 需要加 -f 强制操作 （因为 远程的commit 高于 本地)四： pull 时候和本地冲突error: Your local changes to ‘c/environ.c’ would be overwritten by merge. Aborting. Please, commit your changes or stash them before you can merge.这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。处理的方式非常简单，主要是使用git stash命令进行处理，分成以下几个步骤进行处理。1、先将本地修改存储起来$ git stash这样本地的所有修改就都被暂时存储起来 。是用git stash list可以看到保存的信息：git stash暂存修改其中stash@{0}就是刚才保存的标记。2、pull内容暂存了本地修改之后，就可以pull了。3、还原暂存的内容$git stash pop stash@{0}系统提示如下类似的信息：Auto-merging c/environ.cCONFLICT (content): Merge conflict in c/environ.c意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。4、解决文件中冲突的的部分就可以正常的提交了。五：强制pull git fetch –allgit reset –hard origin/mastergit pull git fetch 只是下载远程的库的内容，不做任何的合并 git reset 把HEAD指向刚刚下载的最新的版本","link":"/2019/10/25/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/21/hello-world/"},{"title":"post title with whitespace","text":"你好","link":"/2019/10/25/post-title-with-whitespace/"},{"title":"test","text":"Test","link":"/2020/04/21/test/"},{"title":"接口与实现类动态切换的四种方式","text":"第一种方式 Spring Map注入方式123456789public interface QuotaService { /** * 评估额度 * @param quotaRequest * @return */ QuotaResponse evaluateQuota(QuotaRequest quotaRequest);} 12@Service(\"mockQuotaService\")public class MockQuotaServiceImpl implements QuotaService 12@Service(\"riskQuotaService\")public class RiskQuotaServiceImpl implements QuotaService 如何使用 12345 @Autowired Map&lt;String, QuotaService&gt; quotaServiceMap; QuotaResponse quota = quotaServiceMap.get(apolloConfigUtil.getQuotaServiceName()).evaluateQuota(quotaRequest); 第二种方式 Spring Bean ApplicationContext12345678public interface BaseProcesser { /** * 获取支付类型 * @return */ PaymentChannelEnum getPayType();} 123456789101112131415161718192021@Servicepublic class PayChannelMappingFactory implements ApplicationContextAware{ //支付模版 private Map&lt;PaymentChannelEnum, BasePayProcesser&gt; payProcesserMap; //支付模版 public BasePayProcesser getPayProcessor(PaymentChannelEnum payType){ return payProcesserMap.get(payType); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { Map payMap = applicationContext.getBeansOfType(BasePayProcesser.class); payProcesserMap = new HashMap&lt;PaymentChannelEnum,BasePayProcesser&gt;(payMap.size()); for(Object object:payMap.values()){ BasePayProcesser processor = (BasePayProcesser)object; payProcesserMap.put(processor.getPayType(),processor); } }} 第三种方式 Java Spi123456789101112131415161718192021222324252627282930313233343536373839public class CallBackMappingFactory { private static ConcurrentHashMap&lt;String, MethodManager&gt; methodMappings = new ConcurrentHashMap&lt;&gt;(); private volatile static boolean init = false; private CallBackMappingFactory(){ } private static void initHandlerMethod() { ServiceLoader&lt;AbstractCallBackReceiveService&gt; baseMethodManagers = ServiceLoader.load(AbstractCallBackReceiveService.class); for(AbstractCallBackReceiveService abstractCallBackReceiveService :baseMethodManagers){ Method[] methods = abstractCallBackReceiveService.getClass().getDeclaredMethods(); for (Method method : methods) { MethodMapping methodMapping = method.getAnnotation(MethodMapping.class); if (methodMapping != null &amp;&amp; methodMapping.value() != null) { String mapping = methodMapping.value(); addMethodMapping(mapping, new MethodManager(StringUtils.uncapitalize(abstractCallBackReceiveService.getClass().getSimpleName()),method)); } } } } private static void addMethodMapping(String mapping, MethodManager methodManager) { methodMappings.put(mapping, methodManager); } public static MethodManager getMethodMapping(String url) { if(!init){ initHandlerMethod(); init = true; } return methodMappings.get(url); }} (需要添加配置文件)META-INF/services/com.qianli.cashmama.pay.service.callback.receive.AbstractCallBackReceiveService 1234com.qianli.cashmama.pay.service.callback.receive.CallBackReceivePaymentServicecom.qianli.cashmama.pay.service.callback.receive.CallBackReceiveRepaymentServicecom.qianli.cashmama.pay.service.callback.receive.CallBackReceiveAuthServicecom.qianli.cashmama.pay.service.callback.receive.CallBackReceiveWithholdService 第四种方式 @PostConstruct 自己维护Map1public static Map&lt;AcceptTypeEnum, AbstractCallBackSendService&gt; handlers = new HashMap&lt;AcceptTypeEnum, AbstractCallBackSendService&gt;(); 1234567891011@Servicepublic class CallBackSendPaymentService extends AbstractCallBackSendService { @Autowired POrderPrePaymentDao pOrderPrePaymentDao; @PostConstruct public void init() { CallBackSendService.handlers.put(AcceptTypeEnum.ACCEPT_TYPE_PAYMENT, this); }}","link":"/2019/11/11/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"}],"tags":[],"categories":[]}