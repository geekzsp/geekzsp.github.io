---
title: 接口与实现类动态切换的四种方式
date: 2019-11-11 16:31:49
tags:
---

# 第一种方式 Spring Map注入方式
```java
public interface QuotaService {

    /**
     * 评估额度
     * @param quotaRequest
     * @return
     */
    QuotaResponse evaluateQuota(QuotaRequest quotaRequest);
}
```
```java
@Service("mockQuotaService")
public class MockQuotaServiceImpl implements QuotaService
```
```java
@Service("riskQuotaService")
public class RiskQuotaServiceImpl implements QuotaService
```
如何使用
```java

    @Autowired
    Map<String, QuotaService> quotaServiceMap;  

   QuotaResponse quota = quotaServiceMap.get(apolloConfigUtil.getQuotaServiceName()).evaluateQuota(quotaRequest);

```
# 第二种方式 Spring Bean ApplicationContext

```java
public interface BaseProcesser {
    /**
     * 获取支付类型
     * @return
     */
    PaymentChannelEnum getPayType();

}
```

```java
@Service
public class PayChannelMappingFactory implements ApplicationContextAware{

    //支付模版
    private Map<PaymentChannelEnum, BasePayProcesser> payProcesserMap;

    //支付模版
    public BasePayProcesser getPayProcessor(PaymentChannelEnum payType){
        return payProcesserMap.get(payType);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map payMap = applicationContext.getBeansOfType(BasePayProcesser.class);
        payProcesserMap = new HashMap<PaymentChannelEnum,BasePayProcesser>(payMap.size());
        for(Object object:payMap.values()){
            BasePayProcesser processor = (BasePayProcesser)object;
            payProcesserMap.put(processor.getPayType(),processor);
        }
    }
}
```
# 第三种方式 Java Spi 

```java
public class CallBackMappingFactory {

    private static ConcurrentHashMap<String, MethodManager> methodMappings = new ConcurrentHashMap<>();

    private volatile static boolean init = false;

    private CallBackMappingFactory(){
    }


    private static void initHandlerMethod() {
        ServiceLoader<AbstractCallBackReceiveService> baseMethodManagers = ServiceLoader.load(AbstractCallBackReceiveService.class);
        for(AbstractCallBackReceiveService abstractCallBackReceiveService :baseMethodManagers){
            Method[] methods = abstractCallBackReceiveService.getClass().getDeclaredMethods();
            for (Method method : methods) {
                MethodMapping methodMapping = method.getAnnotation(MethodMapping.class);
                if (methodMapping != null && methodMapping.value() != null) {

                    String mapping = methodMapping.value();
                    addMethodMapping(mapping, new MethodManager(StringUtils.uncapitalize(abstractCallBackReceiveService.getClass().getSimpleName()),method));
                }
            }
        }
    }

    private static void addMethodMapping(String mapping, MethodManager methodManager) {
        methodMappings.put(mapping, methodManager);

    }

    public static MethodManager getMethodMapping(String url) {

        if(!init){
            initHandlerMethod();
            init = true;
        }
        return methodMappings.get(url);
    }
}

```
(需要添加配置文件)
META-INF/services/com.qianli.cashmama.pay.service.callback.receive.AbstractCallBackReceiveService
```
com.qianli.cashmama.pay.service.callback.receive.CallBackReceivePaymentService
com.qianli.cashmama.pay.service.callback.receive.CallBackReceiveRepaymentService
com.qianli.cashmama.pay.service.callback.receive.CallBackReceiveAuthService
com.qianli.cashmama.pay.service.callback.receive.CallBackReceiveWithholdService

```
# 第四种方式 @PostConstruct 自己维护Map

```Java
 public static Map<AcceptTypeEnum, AbstractCallBackSendService> handlers = new HashMap<AcceptTypeEnum, AbstractCallBackSendService>();
```

```java
@Service
public class CallBackSendPaymentService extends AbstractCallBackSendService {

    @Autowired
    POrderPrePaymentDao pOrderPrePaymentDao;

    @PostConstruct
    public void init() {
        CallBackSendService.handlers.put(AcceptTypeEnum.ACCEPT_TYPE_PAYMENT, this);
    }
}
```
